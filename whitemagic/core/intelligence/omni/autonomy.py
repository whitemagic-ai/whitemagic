# mypy: disable-error-code=no-untyped-def
"""Autonomy Engine - The Self-Driving Mind.
=======================================

"He who conquers others is strong; He who conquers himself is mighty."

The Autonomy Engine is responsible for the system's "Will".
It introspects the friction logs and generates its OWN intents
to improve the system, without user prompting.

Cycle:
1. INTROSPECT: Look at Friction Logs and Memory.
2. JUDGE: Is this friction actionable?
3. WILL: Generate an Intent string.
4. ACT: Send intent to UniversalRouter.
"""

import logging
from dataclasses import dataclass
from datetime import datetime

from whitemagic.core.intelligence.omni.universal_router import get_universal_router

logger = logging.getLogger(__name__)

@dataclass
class SelfIntent:
    """An intent generated by the system itself."""

    source: str  # "friction_log", "optimization_opportunity", etc.
    description: str
    urgency: float
    generated_at: datetime = datetime.now()

class AutonomyEngine:
    """The ghost in the machine that drives self-improvement.
    """

    def __init__(self):
        self.router = get_universal_router()

    def _scan_for_friction(self) -> list[str]:
        """Scan real logs/memory for repeated errors or slow operations.
        Reads the tail of excavation.log.
        """
        frictions = []
        try:
            from pathlib import Path
            # Assuming excavation.log is in the project root based on file listing
            log_path = Path("excavation.log")
            if not log_path.exists():
                # Fallback to logs directory
                log_path = Path("logs/excavation.log")

            if log_path.exists():
                # Read last 100 lines
                with open(log_path, "r") as f:
                    lines = f.readlines()[-100:]

                # Simple pattern matching for friction types
                for line in lines:
                    if "high latency" in line.lower():
                        frictions.append("Detected high latency in system logs.")
                    if "connection lost" in line.lower():
                        frictions.append("Detected connection loss in system logs.")
                    if "error" in line.lower() and "exception" in line.lower():
                        # Extract the error type roughly
                        frictions.append(f"Detected system error: {line.strip()[:100]}")

                # Dedup
                frictions = list(set(frictions))
        except Exception as e:
            logger.warning(f"Failed to scan logs: {e}")

        return frictions

    def generate_self_intent(self) -> SelfIntent | None:
        """Introspect and decide if action is needed.
        """
        frictions = self._scan_for_friction()

        if not frictions:
            return None

        friction = frictions[0]
        logger.info(f"ðŸ‘» Autonomy Engine detected friction: '{friction}'")

        # Convert friction to intent
        intent_desc = f"Analyze and fix {friction.lower()}"

        return SelfIntent(
            source="friction_detector",
            description=intent_desc,
            urgency=0.8,
        )

    async def run_cycle(self):
        """Execute one cycle of self-directed will.
        """
        logger.info("ðŸ‘ï¸ Autonomy Cycle starting...")

        intent = self.generate_self_intent()

        if intent:
            logger.info(f"âš¡ SELF-PROMPTING: '{intent.description}'")

            # The system prompts itself!
            chain = self.router.route(intent.description)

            # Execute the chain
            await self.router.execute(chain)

            logger.info("âœ… Self-improvement cycle completed.")
        else:
            logger.info("Subjective state is stable. No self-action required.")

# Singleton accessor
_autonomy = None
def get_autonomy_engine() -> AutonomyEngine:
    global _autonomy
    if _autonomy is None:
        _autonomy = AutonomyEngine()
    return _autonomy
